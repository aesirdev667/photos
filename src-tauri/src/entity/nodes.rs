//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use sea_orm::entity::prelude::*;
use serde::{Deserialize, Serialize};

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "nodes")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub path: String,
    pub size: i32,
    #[sea_orm(column_type = "custom(\"enum_text\")")]
    pub node_type: String,
    pub parent_id: Option<i32>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,

    #[sea_orm(ignore)]
    #[serde(skip_deserializing, default)]
    pub children: Vec<Model>,
}

// #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
// pub enum Relation {
//     #[sea_orm(
//         belongs_to = "Entity",
//         from = "Column::ParentId",
//         to = "Column::Id",
//         on_update = "NoAction",
//         on_delete = "NoAction"
//     )]
//     SelfRef,
// }

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(
        has_many = "Entity",
        from = "Column::Id",
        to = "Column::ParentId"
    )]
    Children,
}

impl Related<crate::entity::nodes::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Children.def()
    }
}

impl Model {
    pub async fn with_children(mut self, db: &DatabaseConnection) -> Result<Self, DbErr> {
        let all_descendants = Entity::find()
            .filter(Column::ParentId.is_not_null())
            .all(db)
            .await?;

        let mut children_map: std::collections::HashMap<i32, Vec<Model>> = std::collections::HashMap::new();

        for node in all_descendants {
            if let Some(parent_id) = node.parent_id {
                children_map.entry(parent_id)
                    .or_insert_with(Vec::new)
                    .push(node);
            }
        }

        self.children = get_children(&children_map, self.id);

        Ok(self)
    }
}

fn get_children(children_map: &std::collections::HashMap<i32, Vec<Model>>, parent_id: i32) -> Vec<Model> {
    match children_map.get(&parent_id) {
        Some(children) => {
            children.iter().map(|child| {
                let mut child = child.clone();
                child.children = get_children(children_map, child.id);
                child
            }).collect()
        }
        None => Vec::new()
    }
}

impl ActiveModelBehavior for ActiveModel {}
