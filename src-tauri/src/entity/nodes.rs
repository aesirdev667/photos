//! `SeaORM` Entity, @generated by sea-orm-codegen 1.0.1

use sea_orm::entity::prelude::*;
use sea_orm::{FromQueryResult, Statement};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Eq, Serialize, Deserialize)]
#[sea_orm(table_name = "nodes")]
pub struct Model {
    #[sea_orm(primary_key)]
    pub id: i32,
    pub path: String,
    pub size: i32,
    #[sea_orm(column_type = "custom(\"enum_text\")")]
    pub node_type: String,
    pub parent_id: Option<i32>,
    pub created_at: DateTimeUtc,
    pub updated_at: DateTimeUtc,

    #[sea_orm(ignore)]
    #[serde(skip_deserializing, default)]
    pub children: Vec<Model>,
}

// #[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
// pub enum Relation {
//     #[sea_orm(
//         belongs_to = "Entity",
//         from = "Column::ParentId",
//         to = "Column::Id",
//         on_update = "NoAction",
//         on_delete = "NoAction"
//     )]
//     SelfRef,
// }

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
    #[sea_orm(has_many = "Entity", from = "Column::Id", to = "Column::ParentId")]
    Children,
}

impl Related<crate::entity::nodes::Entity> for Entity {
    fn to() -> RelationDef {
        Relation::Children.def()
    }
}

impl Model {
    pub async fn with_children(mut self, db: &DatabaseConnection) -> Result<Self, DbErr> {
        let query = format!(
            "WITH RECURSIVE NodeTree AS (
                SELECT id, path, size, node_type, parent_id, created_at, updated_at
                FROM nodes
                WHERE id = {}

                UNION ALL

                SELECT n.id, n.path, n.size, n.node_type, n.parent_id, n.created_at, n.updated_at
                FROM nodes n
                JOIN NodeTree nt ON n.parent_id = nt.id
            )
            SELECT *
            FROM NodeTree;",
            self.id
        );

        let all_nodes: Vec<Model> = Model::find_by_statement(Statement::from_sql_and_values(
            db.get_database_backend(),
            &query,
            vec![],
        ))
        .all(db)
        .await?;

        // Create initial map of all nodes
        let mut node_map: HashMap<i32, Model> =
            all_nodes.into_iter().map(|node| (node.id, node)).collect();

        // First, move all files to their parent directories
        let file_ids: Vec<i32> = node_map
            .values()
            .filter(|node| node.node_type == "file")
            .map(|node| node.id)
            .collect();

        for file_id in file_ids {
            if let Some(file_node) = node_map.remove(&file_id) {
                if let Some(parent_id) = file_node.parent_id {
                    if let Some(parent) = node_map.get_mut(&parent_id) {
                        parent.children.push(file_node);
                    }
                }
            }
        }

        // Then move directories to their parents, starting from the deepest
        let mut dir_ids: Vec<i32> = node_map
            .values()
            .filter(|node| node.node_type == "directory" && node.id != self.id)
            .map(|node| node.id)
            .collect();

        // Sort directories by path length (descending) to process deepest first
        dir_ids.sort_by_key(|id| {
            node_map
                .get(id)
                .map(|node| node.path.matches('/').count())
                .unwrap_or(0)
        });
        dir_ids.reverse();

        for dir_id in dir_ids {
            if let Some(dir_node) = node_map.remove(&dir_id) {
                if let Some(parent_id) = dir_node.parent_id {
                    if let Some(parent) = node_map.get_mut(&parent_id) {
                        parent.children.push(dir_node);
                    }
                }
            }
        }

        // Finally, set the root node's children
        if let Some(root) = node_map.remove(&self.id) {
            self.children = root.children;
        }

        Ok(self)
    }
}

impl ActiveModelBehavior for ActiveModel {}
